// CONTRACT: q4k-q6k-superblock-v1.yaml
// HASH: sha256:a1b2c3d4e5f67890
// Generated by: pv probar --binding
// DO NOT EDIT — regenerate with `pv probar --binding`

use proptest::prelude::*;

/// Q4K superblock: 2(d) + 2(dmin) + 12(scales) + 128(quants) = 144 bytes for 256 elements
const Q4K_D_BYTES: u32 = 2;
const Q4K_DMIN_BYTES: u32 = 2;
const Q4K_SCALES_BYTES: u32 = 12;
const Q4K_QUANTS_BYTES: u32 = 128;
const Q4K_BLOCK_SIZE: u32 = Q4K_D_BYTES + Q4K_DMIN_BYTES + Q4K_SCALES_BYTES + Q4K_QUANTS_BYTES;
const Q4K_ELEMENTS: u32 = 256;

/// Q6K superblock: 128(ql) + 64(qh) + 16(scales) + 2(d) = 210 bytes for 256 elements
const Q6K_QL_BYTES: u32 = 128;
const Q6K_QH_BYTES: u32 = 64;
const Q6K_SCALES_BYTES: u32 = 16;
const Q6K_D_BYTES: u32 = 2;
const Q6K_BLOCK_SIZE: u32 = Q6K_QL_BYTES + Q6K_QH_BYTES + Q6K_SCALES_BYTES + Q6K_D_BYTES;
const Q6K_ELEMENTS: u32 = 256;

/// Total bytes for a quantized weight matrix.
fn total_bytes(rows: u32, cols: u32, block_size: u32, elements_per_block: u32) -> u64 {
    let blocks_per_row = (cols as u64 + elements_per_block as u64 - 1) / elements_per_block as u64;
    rows as u64 * blocks_per_row * block_size as u64
}

/// Simplified dequantization: x_i = d * scale * quant - dmin * min_scale
fn dequant_q4k(d: f32, dmin: f32, scale: u8, min_scale: u8, quant: u8) -> f32 {
    d * scale as f32 * (quant & 0xF) as f32 - dmin * min_scale as f32
}

proptest! {
    /// Obligation: Q4K superblock size (invariant)
    /// Formal: 2 + 2 + 12 + 128 = 144
    #[test]
    fn prop_q4k_superblock_size(
        _dummy in 0u8..1
    ) {
        prop_assert_eq!(Q4K_BLOCK_SIZE, 144, "Q4K block size = {}, expected 144", Q4K_BLOCK_SIZE);
        prop_assert_eq!(Q4K_ELEMENTS, 256, "Q4K elements = {}, expected 256", Q4K_ELEMENTS);
        // Effective bits per weight
        let bpw = Q4K_BLOCK_SIZE as f64 * 8.0 / Q4K_ELEMENTS as f64;
        prop_assert!((bpw - 4.5).abs() < 0.01, "Q4K bpw = {}, expected 4.5", bpw);
    }

    /// Obligation: Q6K superblock size (invariant)
    /// Formal: 128 + 64 + 16 + 2 = 210
    #[test]
    fn prop_q6k_superblock_size(
        _dummy in 0u8..1
    ) {
        prop_assert_eq!(Q6K_BLOCK_SIZE, 210, "Q6K block size = {}, expected 210", Q6K_BLOCK_SIZE);
        prop_assert_eq!(Q6K_ELEMENTS, 256, "Q6K elements = {}, expected 256", Q6K_ELEMENTS);
        let bpw = Q6K_BLOCK_SIZE as f64 * 8.0 / Q6K_ELEMENTS as f64;
        prop_assert!((bpw - 6.5625).abs() < 0.01, "Q6K bpw = {}, expected 6.5625", bpw);
    }

    /// Obligation: Total bytes monotonic (monotonicity)
    /// Formal: cols1 < cols2 => total_bytes(r, cols1) <= total_bytes(r, cols2)
    #[test]
    fn prop_total_bytes_monotonic(
        rows in 1u32..1000,
        cols1 in 1u32..10000,
        delta in 1u32..10000
    ) {
        let cols2 = cols1.saturating_add(delta);
        let bytes1 = total_bytes(rows, cols1, Q4K_BLOCK_SIZE, Q4K_ELEMENTS);
        let bytes2 = total_bytes(rows, cols2, Q4K_BLOCK_SIZE, Q4K_ELEMENTS);
        prop_assert!(
            bytes2 >= bytes1,
            "not monotonic: cols1={} -> {} bytes, cols2={} -> {} bytes",
            cols1, bytes1, cols2, bytes2
        );
    }

    /// Obligation: Dequant produces finite (invariant)
    /// Formal: x_i is finite for valid superblock inputs
    #[test]
    fn prop_dequant_finite(
        d in -100.0f32..100.0,
        dmin in -100.0f32..100.0,
        scale in 0u8..=63,
        min_scale in 0u8..=63,
        quant in 0u8..=255
    ) {
        let result = dequant_q4k(d, dmin, scale, min_scale, quant);
        prop_assert!(
            result.is_finite(),
            "dequant not finite: d={}, dmin={}, scale={}, min_scale={}, quant={} -> {}",
            d, dmin, scale, min_scale, quant, result
        );
    }

    /// Obligation: Offset vanishing (invariant)
    /// Formal: has_dmin=false => offset_term = 0
    #[test]
    fn prop_offset_vanishing(
        d_val in -10.0f32..10.0,
        scale in 0u8..=63,
        quant in 0u8..=255
    ) {
        // When dmin=0 (no offset), result = d * scale * quant_low_nibble
        let result = dequant_q4k(d_val, 0.0, scale, 0, quant);
        let expected = d_val * scale as f32 * (quant & 0xF) as f32;
        let diff = (result - expected).abs();
        prop_assert!(
            diff < 1e-6,
            "offset vanishing: result={}, expected={}, diff={}",
            result, expected, diff
        );
    }

    /// Obligation: bsum weight independence (invariant)
    /// Formal: bsum depends on quantized values only, not on scale factors
    #[test]
    fn prop_bsum_independence(
        quants in proptest::collection::vec(0u8..=255, 32..=32usize)
    ) {
        // bsum = sum of all quantized values in a block (low nibbles for Q4K)
        let bsum: u32 = quants.iter().map(|&q| (q & 0xF) as u32).sum();

        // Same quants, different scale: bsum should be identical
        let bsum2: u32 = quants.iter().map(|&q| (q & 0xF) as u32).sum();
        prop_assert_eq!(bsum, bsum2, "bsum not weight-independent");

        // bsum is bounded: max per element is 15, 32 elements => max 480
        prop_assert!(bsum <= 480, "bsum {} exceeds max 480", bsum);
    }

    /// Obligation: SIMD dequant equivalence (equivalence)
    #[test]
    #[ignore = "SIMD equivalence — trueno domain"]
    fn prop_simd_equivalence(
        _x in proptest::collection::vec(0u8..=255, 1..32usize)
    ) {
        // SIMD dequant testing is trueno's responsibility
    }
}
