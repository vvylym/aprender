// CONTRACT: metrics-clustering-v1.yaml
// HASH: sha256:a1b2c3d4e5f60789
// Generated by: pv probar --binding
// DO NOT EDIT — regenerate with `pv probar --binding`

use aprender::metrics::{inertia, silhouette_score};
use aprender::primitives::Matrix;
use proptest::prelude::*;

proptest! {
    /// FALSIFY-CL-001: Silhouette bounded
    /// Formal: silhouette_score(X, labels) ∈ [-1, 1]
    #[test]
    fn prop_silhouette_bounded(
        // Generate random 2D data: 10–30 points, values in [-100, 100]
        n in 10usize..30,
        seed in 0u64..1000,
    ) {
        // Build deterministic pseudo-random data from seed
        let mut vals = Vec::with_capacity(n * 2);
        let mut rng = seed;
        for _ in 0..(n * 2) {
            // Simple LCG for reproducibility
            rng = rng.wrapping_mul(6_364_136_223_846_793_005).wrapping_add(1);
            let v = ((rng >> 33) as f32 / (u32::MAX >> 1) as f32) * 200.0 - 100.0;
            vals.push(v);
        }
        let data = Matrix::from_vec(n, 2, vals).expect("valid dimensions");

        // Assign to 2 or 3 clusters via modular arithmetic
        let k = if seed % 2 == 0 { 2 } else { 3 };
        let labels: Vec<usize> = (0..n).map(|i| i % k).collect();

        let score = silhouette_score(&data, &labels);

        prop_assert!(
            (-1.0..=1.0).contains(&score),
            "FALSIFY-CL-001: silhouette_score={score}, expected ∈ [-1, 1]"
        );
    }

    /// FALSIFY-CL-002: Inertia non-negative
    /// Formal: inertia(X, centroids, labels) ≥ 0
    #[test]
    fn prop_inertia_non_negative(
        n in 6usize..20,
        seed in 0u64..1000,
    ) {
        let k = 2usize;

        // Generate random data
        let mut vals = Vec::with_capacity(n * 2);
        let mut rng = seed;
        for _ in 0..(n * 2) {
            rng = rng.wrapping_mul(6_364_136_223_846_793_005).wrapping_add(1);
            let v = ((rng >> 33) as f32 / (u32::MAX >> 1) as f32) * 200.0 - 100.0;
            vals.push(v);
        }
        let data = Matrix::from_vec(n, 2, vals).expect("valid dimensions");

        // Assign labels and compute naive centroids
        let labels: Vec<usize> = (0..n).map(|i| i % k).collect();

        let mut centroid_sums = vec![vec![0.0f32; 2]; k];
        let mut centroid_counts = vec![0usize; k];
        for (i, &label) in labels.iter().enumerate() {
            for d in 0..2 {
                centroid_sums[label][d] += data.get(i, d);
            }
            centroid_counts[label] += 1;
        }
        let mut centroid_vals = Vec::with_capacity(k * 2);
        for c in 0..k {
            for d in 0..2 {
                centroid_vals.push(centroid_sums[c][d] / centroid_counts[c] as f32);
            }
        }
        let centroids = Matrix::from_vec(k, 2, centroid_vals).expect("valid centroid dims");

        let result = inertia(&data, &centroids, &labels);

        prop_assert!(
            result >= 0.0,
            "FALSIFY-CL-002: inertia={result}, expected ≥ 0"
        );
    }

    /// FALSIFY-CL-003: Silhouette degenerate (single cluster returns 0)
    /// Formal: |{unique labels}| = 1 ⟹ silhouette_score = 0
    #[test]
    fn prop_silhouette_degenerate_single_cluster(
        n in 2usize..20,
        seed in 0u64..1000,
    ) {
        // Generate random data
        let mut vals = Vec::with_capacity(n * 2);
        let mut rng = seed;
        for _ in 0..(n * 2) {
            rng = rng.wrapping_mul(6_364_136_223_846_793_005).wrapping_add(1);
            let v = ((rng >> 33) as f32 / (u32::MAX >> 1) as f32) * 50.0 - 25.0;
            vals.push(v);
        }
        let data = Matrix::from_vec(n, 2, vals).expect("valid dimensions");

        // All points in cluster 0 — single cluster
        let labels = vec![0usize; n];

        let score = silhouette_score(&data, &labels);

        prop_assert!(
            (score - 0.0).abs() < f32::EPSILON,
            "FALSIFY-CL-003: silhouette_score={score} for single cluster, expected 0.0"
        );
    }

    /// FALSIFY-CL-004: Well-separated clusters yield silhouette > 0.5
    /// Formal: gap ≫ intra-cluster spread ⟹ silhouette_score > 0.5
    #[test]
    fn prop_well_separated_high_silhouette(
        // Cluster center gap in [50, 200], noise radius in [0.01, 1.0]
        gap in 50.0f32..200.0,
        noise_scale in 0.01f32..1.0,
        seed in 0u64..1000,
    ) {
        // Two tight clusters separated by `gap`
        let points_per_cluster = 10usize;
        let n = points_per_cluster * 2;
        let mut vals = Vec::with_capacity(n * 2);
        let mut rng = seed;

        // Cluster A centered at (0, 0)
        for _ in 0..points_per_cluster {
            for _ in 0..2 {
                rng = rng.wrapping_mul(6_364_136_223_846_793_005).wrapping_add(1);
                let noise = ((rng >> 33) as f32 / (u32::MAX >> 1) as f32) * 2.0 - 1.0;
                vals.push(noise * noise_scale);
            }
        }
        // Cluster B centered at (gap, gap)
        for _ in 0..points_per_cluster {
            for _ in 0..2 {
                rng = rng.wrapping_mul(6_364_136_223_846_793_005).wrapping_add(1);
                let noise = ((rng >> 33) as f32 / (u32::MAX >> 1) as f32) * 2.0 - 1.0;
                vals.push(gap + noise * noise_scale);
            }
        }

        let data = Matrix::from_vec(n, 2, vals).expect("valid dimensions");
        let mut labels = vec![0usize; n];
        for i in points_per_cluster..n {
            labels[i] = 1;
        }

        let score = silhouette_score(&data, &labels);

        prop_assert!(
            score > 0.5,
            "FALSIFY-CL-004: silhouette_score={score} for well-separated clusters \
             (gap={gap}, noise={noise_scale}), expected > 0.5"
        );
    }
}
