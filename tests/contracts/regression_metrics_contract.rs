// CONTRACT: metrics-regression-v1.yaml
// HASH: sha256:a1b2c3d4e5f67890
// Generated by: pv probar --binding
// DO NOT EDIT — regenerate with `pv probar --binding`

use aprender::metrics::{mae, mse, r_squared, rmse};
use aprender::primitives::Vector;
use proptest::prelude::*;

/// Strategy: generate a non-empty vector of finite f32 values.
/// Avoids NaN/Inf which would poison metric computations.
fn finite_vec(min_len: usize, max_len: usize) -> impl Strategy<Value = Vec<f32>> {
    proptest::collection::vec(-1e6_f32..1e6, min_len..=max_len)
}

proptest! {
    #![proptest_config(ProptestConfig::with_cases(512))]

    // ──────────────────────────────────────────────────────────
    // FALSIFY-RM-001: R² upper bound
    // Formal: R²(y, ŷ) ≤ 1.0  for all y, ŷ ∈ ℝⁿ
    // ──────────────────────────────────────────────────────────
    /// Obligation: R² never exceeds 1.0 (upper bound)
    /// Formal: R² = 1 - SS_res/SS_tot ≤ 1.0
    #[test]
    fn falsify_rm_001_r2_upper_bound(
        y_true_raw in finite_vec(2, 128),
        y_pred_raw in finite_vec(2, 128),
    ) {
        let len = y_true_raw.len().min(y_pred_raw.len());
        let y_true = Vector::from_slice(&y_true_raw[..len]);
        let y_pred = Vector::from_slice(&y_pred_raw[..len]);

        let r2 = r_squared(&y_pred, &y_true);

        prop_assert!(
            r2 <= 1.0 + 1e-6,
            "FALSIFY-RM-001 violated: R²={r2} > 1.0 for n={len}"
        );
    }

    // ──────────────────────────────────────────────────────────
    // FALSIFY-RM-002: MSE non-negativity
    // Formal: MSE(y, ŷ) ≥ 0  for all y, ŷ ∈ ℝⁿ
    // ──────────────────────────────────────────────────────────
    /// Obligation: MSE is always non-negative (lower bound)
    /// Formal: MSE = (1/n) Σ(yᵢ - ŷᵢ)² ≥ 0
    #[test]
    fn falsify_rm_002_mse_non_negative(
        y_true_raw in finite_vec(1, 128),
        y_pred_raw in finite_vec(1, 128),
    ) {
        let len = y_true_raw.len().min(y_pred_raw.len());
        let y_true = Vector::from_slice(&y_true_raw[..len]);
        let y_pred = Vector::from_slice(&y_pred_raw[..len]);

        let mse_val = mse(&y_pred, &y_true);

        prop_assert!(
            mse_val >= 0.0,
            "FALSIFY-RM-002 violated: MSE={mse_val} < 0 for n={len}"
        );
    }

    // ──────────────────────────────────────────────────────────
    // FALSIFY-RM-003: MAE ≤ RMSE (Jensen's inequality)
    // Formal: E[|X|] ≤ √(E[X²])  by concavity of √
    // ──────────────────────────────────────────────────────────
    /// Obligation: MAE never exceeds RMSE (Jensen's inequality)
    /// Formal: MAE = (1/n)Σ|eᵢ| ≤ √((1/n)Σeᵢ²) = RMSE
    #[test]
    fn falsify_rm_003_mae_leq_rmse(
        y_true_raw in finite_vec(1, 128),
        y_pred_raw in finite_vec(1, 128),
    ) {
        let len = y_true_raw.len().min(y_pred_raw.len());
        let y_true = Vector::from_slice(&y_true_raw[..len]);
        let y_pred = Vector::from_slice(&y_pred_raw[..len]);

        let mae_val = mae(&y_pred, &y_true);
        let rmse_val = rmse(&y_pred, &y_true);

        prop_assert!(
            mae_val <= rmse_val + 1e-4,
            "FALSIFY-RM-003 violated: MAE={mae_val} > RMSE={rmse_val} (Jensen's inequality) for n={len}"
        );
    }

    // ──────────────────────────────────────────────────────────
    // FALSIFY-RM-004: Perfect prediction identity
    // Formal: ŷ = y ⟹ R²≈1 ∧ MSE≈0 ∧ MAE≈0 ∧ RMSE≈0
    // ──────────────────────────────────────────────────────────
    /// Obligation: Perfect predictions yield ideal metric values
    /// Formal: when ŷᵢ = yᵢ for all i: R²=1, MSE=0, MAE=0, RMSE=0
    #[test]
    fn falsify_rm_004_perfect_prediction(
        y_raw in finite_vec(2, 128),
    ) {
        // Ensure non-constant y (otherwise SS_tot = 0 and R² is degenerate)
        prop_assume!(y_raw.windows(2).any(|w| (w[0] - w[1]).abs() > 1e-10));

        let y = Vector::from_slice(&y_raw);
        let y_hat = Vector::from_slice(&y_raw);

        let r2 = r_squared(&y_hat, &y);
        let mse_val = mse(&y_hat, &y);
        let mae_val = mae(&y_hat, &y);
        let rmse_val = rmse(&y_hat, &y);

        prop_assert!(
            (r2 - 1.0).abs() < 1e-5,
            "FALSIFY-RM-004 violated: R²={r2}, expected ≈1.0 for perfect prediction"
        );
        prop_assert!(
            mse_val < 1e-10,
            "FALSIFY-RM-004 violated: MSE={mse_val}, expected ≈0 for perfect prediction"
        );
        prop_assert!(
            mae_val < 1e-10,
            "FALSIFY-RM-004 violated: MAE={mae_val}, expected ≈0 for perfect prediction"
        );
        prop_assert!(
            rmse_val < 1e-5,
            "FALSIFY-RM-004 violated: RMSE={rmse_val}, expected ≈0 for perfect prediction"
        );
    }

    // ──────────────────────────────────────────────────────────
    // FALSIFY-RM-005: MSE symmetry
    // Formal: MSE(y, ŷ) = MSE(ŷ, y)  (squared error is symmetric)
    // ──────────────────────────────────────────────────────────
    /// Obligation: MSE is symmetric in its arguments
    /// Formal: (aᵢ - bᵢ)² = (bᵢ - aᵢ)² ⟹ MSE(a,b) = MSE(b,a)
    #[test]
    fn falsify_rm_005_mse_symmetry(
        y_true_raw in finite_vec(1, 128),
        y_pred_raw in finite_vec(1, 128),
    ) {
        let len = y_true_raw.len().min(y_pred_raw.len());
        let y_true = Vector::from_slice(&y_true_raw[..len]);
        let y_pred = Vector::from_slice(&y_pred_raw[..len]);

        let mse_fwd = mse(&y_pred, &y_true);
        let mse_rev = mse(&y_true, &y_pred);

        prop_assert!(
            (mse_fwd - mse_rev).abs() < 1e-4,
            "FALSIFY-RM-005 violated: MSE(y,ŷ)={mse_fwd} ≠ MSE(ŷ,y)={mse_rev}"
        );
    }
}
