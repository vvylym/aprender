// CONTRACT: kmeans-kernel-v1.yaml
// HASH: sha256:e5f6a7b8c9d01234
// Generated by: pv probar --binding
// DO NOT EDIT — regenerate with `pv probar --binding`

use aprender::cluster::KMeans;
use aprender::primitives::Matrix;
use aprender::traits::UnsupervisedEstimator;
use proptest::prelude::*;

proptest! {
    /// Obligation: Nearest centroid assignment (invariant)
    /// Formal: assignment minimizes distance to centroid
    #[test]
    fn prop_nearest_centroid(
        seed in 0u64..100
    ) {
        // Generate two well-separated clusters
        let data = Matrix::from_vec(6, 2, vec![
            0.0, 0.0,
            0.1, 0.1,
            0.2, 0.0,
            10.0, 10.0,
            10.1, 10.1,
            10.2, 10.0,
        ]).expect("valid dimensions");

        let mut km = KMeans::new(2).with_max_iter(100).with_random_state(seed);
        km.fit(&data).expect("fit succeeds");
        let labels = km.predict(&data);
        let centroids = km.centroids();

        // Each point should be closer to its assigned centroid than to the other
        for i in 0..6 {
            let assigned = labels[i];
            let other = 1 - assigned;
            let mut dist_assigned = 0.0f32;
            let mut dist_other = 0.0f32;
            for d in 0..2 {
                let val = data.get(i, d);
                let ca = centroids.get(assigned, d);
                let co = centroids.get(other, d);
                dist_assigned += (val - ca).powi(2);
                dist_other += (val - co).powi(2);
            }
            prop_assert!(
                dist_assigned <= dist_other + 1e-6,
                "point {i}: dist_assigned={dist_assigned} > dist_other={dist_other}"
            );
        }
    }

    /// Obligation: Objective non-increasing (monotonicity)
    /// Formal: J_{t+1} <= J_t across iterations
    #[test]
    fn prop_objective_non_increasing(
        seed in 0u64..100
    ) {
        let data = Matrix::from_vec(6, 2, vec![
            0.0, 0.0,
            1.0, 0.0,
            0.0, 1.0,
            10.0, 10.0,
            11.0, 10.0,
            10.0, 11.0,
        ]).expect("valid dimensions");

        // Run with 1 iteration
        let mut km1 = KMeans::new(2).with_max_iter(1).with_random_state(seed);
        km1.fit(&data).expect("fit succeeds");
        let inertia1 = km1.inertia();

        // Run with many iterations (should converge to <= inertia)
        let mut km_full = KMeans::new(2).with_max_iter(100).with_random_state(seed);
        km_full.fit(&data).expect("fit succeeds");
        let inertia_full = km_full.inertia();

        prop_assert!(
            inertia_full <= inertia1 + 1e-6,
            "inertia not decreasing: full={inertia_full} > 1-iter={inertia1}"
        );
    }

    /// Obligation: Objective non-negative (bound)
    /// Formal: J >= 0
    #[test]
    fn prop_objective_non_negative(
        seed in 0u64..100
    ) {
        let data = Matrix::from_vec(4, 2, vec![
            1.0, 2.0, 3.0, 4.0,
            5.0, 6.0, 7.0, 8.0,
        ]).expect("valid dimensions");

        let mut km = KMeans::new(2).with_random_state(seed);
        km.fit(&data).expect("fit succeeds");
        let inertia = km.inertia();

        prop_assert!(
            inertia >= 0.0,
            "inertia={inertia}, expected >= 0"
        );
    }

    /// Obligation: Valid cluster indices (invariant)
    /// Formal: c_i ∈ {0, ..., K-1} for all i
    #[test]
    fn prop_valid_cluster_indices(
        k in 2usize..5,
        seed in 0u64..100
    ) {
        let data = Matrix::from_vec(8, 2, vec![
            0.0, 0.0, 1.0, 0.0, 0.0, 1.0, 1.0, 1.0,
            5.0, 5.0, 6.0, 5.0, 5.0, 6.0, 6.0, 6.0,
        ]).expect("valid dimensions");

        let mut km = KMeans::new(k).with_random_state(seed);
        km.fit(&data).expect("fit succeeds");
        let labels = km.predict(&data);

        for (i, &label) in labels.iter().enumerate() {
            prop_assert!(
                label < k,
                "label[{i}]={label}, expected < {k}"
            );
        }
    }

    /// Obligation: SIMD matches scalar within ULP (equivalence)
    #[test]
    #[ignore = "SIMD equivalence — trueno domain"]
    fn prop_simd_equivalence(
        _x in proptest::collection::vec(-10.0f32..10.0, 1..32usize)
    ) {
        // SIMD equivalence testing is trueno's responsibility
    }
}
