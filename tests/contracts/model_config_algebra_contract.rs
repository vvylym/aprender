// CONTRACT: model-config-algebra-v1.yaml
// HASH: sha256:e1f2a3b4c5d67890
// Generated by: pv probar --binding
// DO NOT EDIT — regenerate with `pv probar --binding`

use proptest::prelude::*;

/// Strategy: generate valid transformer configs with proper divisibility.
/// hidden_dim is a multiple of num_heads, num_heads is a multiple of num_kv_heads,
/// head_dim = hidden_dim / num_heads must be even.
fn valid_config_strategy(
) -> impl Strategy<Value = (usize, usize, usize, usize, usize, usize, usize)> {
    // num_kv_heads in [1, 8]
    (1usize..=8).prop_flat_map(|n_kv| {
        // gqa_group in [1, 8] => num_heads = n_kv * gqa_group
        (1usize..=8).prop_flat_map(move |gqa_group| {
            let n_h = n_kv * gqa_group;
            // head_dim must be even, in [2, 128] step 2
            (1usize..=64).prop_map(move |half_d_k| {
                let d_k = half_d_k * 2; // always even
                let hidden = n_h * d_k;
                // d_ff must be > hidden
                let d_ff = hidden * 2 + 256; // guaranteed > hidden
                let num_layers = 4;
                let vocab_size = 1000;
                let max_position = 2048;
                (hidden, n_h, n_kv, d_k, d_ff, num_layers, vocab_size)
            })
        })
    })
}

proptest! {
    /// Obligation: Divisibility constraints (invariant)
    /// Formal: h % n_h == 0 ∧ n_h % n_kv == 0 ∧ d_k % 2 == 0
    #[test]
    fn prop_divisibility(
        (hidden, n_h, n_kv, d_k, _d_ff, _layers, _vocab) in valid_config_strategy()
    ) {
        // L1: hidden_dim divisible by num_heads
        prop_assert_eq!(hidden % n_h, 0, "hidden_dim {} not divisible by num_heads {}", hidden, n_h);

        // L1: num_heads divisible by num_kv_heads
        prop_assert_eq!(n_h % n_kv, 0, "num_heads {} not divisible by num_kv_heads {}", n_h, n_kv);

        // L1: head_dim is even (required for RoPE)
        prop_assert_eq!(d_k % 2, 0, "head_dim {} is odd (RoPE requires even)", d_k);

        // Derived: head_dim matches
        prop_assert_eq!(hidden / n_h, d_k, "head_dim mismatch: {} != {}", hidden / n_h, d_k);
    }

    /// Obligation: Dimension bounds (bound)
    /// Formal: d_k >= h/n_h, d_k <= 2*(h/n_h)
    #[test]
    fn prop_bounds(
        (hidden, n_h, _n_kv, d_k, d_ff, _layers, _vocab) in valid_config_strategy()
    ) {
        let expected_d_k = hidden / n_h;
        prop_assert!(
            d_k >= expected_d_k,
            "head_dim {} < hidden/num_heads {}", d_k, expected_d_k
        );
        // FFN expansion: d_ff > hidden
        prop_assert!(
            d_ff > hidden,
            "d_ff {} not greater than hidden {}", d_ff, hidden
        );
    }

    /// Obligation: Parameter ordering (ordering)
    /// Formal: d_ff > h, n_kv <= n_h, max_pos > 0
    #[test]
    fn prop_ordering(
        (hidden, n_h, n_kv, _d_k, d_ff, _layers, _vocab) in valid_config_strategy()
    ) {
        prop_assert!(d_ff > hidden, "d_ff {} <= hidden {}", d_ff, hidden);
        prop_assert!(n_kv <= n_h, "n_kv {} > n_h {}", n_kv, n_h);
    }

    /// Obligation: Non-degeneracy (invariant)
    /// Formal: h>0, L>0, n_h>0, V>0, n_kv>0, d_k>0
    #[test]
    fn prop_non_degeneracy(
        (hidden, n_h, n_kv, d_k, d_ff, layers, vocab) in valid_config_strategy()
    ) {
        prop_assert!(hidden > 0, "hidden_dim must be > 0");
        prop_assert!(n_h > 0, "num_heads must be > 0");
        prop_assert!(n_kv > 0, "num_kv_heads must be > 0");
        prop_assert!(d_k > 0, "head_dim must be > 0");
        prop_assert!(d_ff > 0, "d_ff must be > 0");
        prop_assert!(layers > 0, "num_layers must be > 0");
        prop_assert!(vocab > 0, "vocab_size must be > 0");
    }

    /// Obligation: Cross-parameter constraints (invariant)
    /// Formal: rope_theta > 0 ∧ finite ∧ rms_norm_eps ∈ (0, 0.1)
    #[test]
    fn prop_cross_constraint(
        rope_theta in 1.0f64..1_000_001.0,
        rms_norm_eps in 1e-8f64..0.1
    ) {
        prop_assert!(rope_theta > 0.0, "rope_theta must be positive");
        prop_assert!(rope_theta.is_finite(), "rope_theta must be finite");
        prop_assert!(rms_norm_eps > 0.0, "rms_norm_eps must be positive");
        prop_assert!(rms_norm_eps < 0.1, "rms_norm_eps must be < 0.1");
    }

    /// Obligation: SIMD config equivalence (equivalence)
    #[test]
    #[ignore = "SIMD equivalence — trueno domain"]
    fn prop_simd_equivalence(
        _x in proptest::collection::vec(-10.0f32..10.0, 1..32usize)
    ) {
        // Config algebra is pure integer math — no SIMD variant
    }
}
