// CONTRACT: qwen35-shapes-v1.yaml
// HASH: sha256:e5f6789012345678
// Generated by: pv probar --binding
// DO NOT EDIT — regenerate with `pv probar --binding`

use proptest::prelude::*;

/// Qwen3.5-9B concrete configuration.
const HIDDEN_DIM: usize = 4096;
const NUM_HEADS: usize = 16;
const NUM_KV_HEADS: usize = 4;
const HEAD_DIM: usize = 256;
const INTERMEDIATE_DIM: usize = 12288;
const _ROPE_THETA: f64 = 1_000_000.0;

/// RoPE frequency at position i: base^(-2i/d_k)
fn rope_frequency(base: f64, i: usize, head_dim: usize) -> f64 {
    base.powf(-2.0 * i as f64 / head_dim as f64)
}

proptest! {
    /// Obligation: Q projection shape (invariant)
    /// Formal: n_h * d_k = 4096 for Qwen3.5-9B
    #[test]
    fn prop_q_projection_shape(
        _dummy in 0u8..1
    ) {
        let q_out_dim = NUM_HEADS * HEAD_DIM;
        prop_assert_eq!(
            q_out_dim, HIDDEN_DIM,
            "Q projection: {} * {} = {}, expected {}",
            NUM_HEADS, HEAD_DIM, q_out_dim, HIDDEN_DIM
        );
        // Q projection is square for this config
        prop_assert_eq!(q_out_dim, HIDDEN_DIM, "Q projection not square");
    }

    /// Obligation: KV projection shape (invariant)
    /// Formal: n_kv * d_k = 1024 for Qwen3.5-9B
    #[test]
    fn prop_kv_projection_shape(
        _dummy in 0u8..1
    ) {
        let kv_out_dim = NUM_KV_HEADS * HEAD_DIM;
        prop_assert_eq!(kv_out_dim, 1024, "KV projection: {} * {} = {}, expected 1024",
            NUM_KV_HEADS, HEAD_DIM, kv_out_dim);

        // GQA ratio
        let gqa_ratio = NUM_HEADS / NUM_KV_HEADS;
        prop_assert_eq!(gqa_ratio, 4, "GQA ratio = {}, expected 4", gqa_ratio);
        prop_assert_eq!(NUM_HEADS % NUM_KV_HEADS, 0, "GQA not exact divisor");
    }

    /// Obligation: SwiGLU expansion ratio (invariant)
    /// Formal: 12288 / 4096 = 3.0
    #[test]
    fn prop_swiglu_ratio(
        _dummy in 0u8..1
    ) {
        let ratio = INTERMEDIATE_DIM as f64 / HIDDEN_DIM as f64;
        prop_assert!(
            (ratio - 3.0).abs() < 1e-10,
            "SwiGLU ratio = {}, expected 3.0", ratio
        );
    }

    /// Obligation: O projection transpose (invariant)
    /// Formal: shape(o_proj) == reverse(shape(q_proj))
    #[test]
    fn prop_o_projection_transpose(
        _dummy in 0u8..1
    ) {
        let q_shape = (NUM_HEADS * HEAD_DIM, HIDDEN_DIM);
        let o_shape = (HIDDEN_DIM, NUM_HEADS * HEAD_DIM);
        prop_assert_eq!(
            o_shape, (q_shape.1, q_shape.0),
            "O shape {:?} != transpose of Q shape {:?}", o_shape, q_shape
        );
    }

    /// Obligation: RoPE frequency vector length (invariant)
    /// Formal: len(freqs) == d_k / 2
    #[test]
    fn prop_rope_frequency_length(
        head_dim in (2usize..128).prop_map(|d| d * 2)  // even head dims
    ) {
        let freq_len = head_dim / 2;
        prop_assert!(freq_len > 0, "freq_len must be > 0");
        prop_assert_eq!(
            freq_len * 2, head_dim,
            "freq_len * 2 = {} != head_dim = {}", freq_len * 2, head_dim
        );
    }

    /// Obligation: RoPE frequency decreasing (monotonicity)
    /// Formal: freq_i > freq_{i+1} for all i
    #[test]
    fn prop_rope_frequency_decreasing(
        base in 1000.0f64..10_000_000.0,
        head_dim in (2usize..64).prop_map(|d| d * 2)
    ) {
        let freq_len = head_dim / 2;
        let freqs: Vec<f64> = (0..freq_len)
            .map(|i| rope_frequency(base, i, head_dim))
            .collect();

        // First frequency should be 1.0
        prop_assert!(
            (freqs[0] - 1.0).abs() < 1e-10,
            "freq_0 = {}, expected 1.0", freqs[0]
        );

        // Strictly decreasing
        for i in 0..freq_len - 1 {
            prop_assert!(
                freqs[i] > freqs[i + 1],
                "not decreasing: freq[{}]={} <= freq[{}]={}",
                i, freqs[i], i + 1, freqs[i + 1]
            );
        }

        // All positive
        for (i, &f) in freqs.iter().enumerate() {
            prop_assert!(f > 0.0, "freq[{}] = {} not positive", i, f);
        }
    }

    /// Obligation: SIMD shape equivalence (equivalence)
    #[test]
    #[ignore = "SIMD equivalence — trueno domain"]
    fn prop_simd_equivalence(
        _x in proptest::collection::vec(0u8..=255, 1..32usize)
    ) {
        // Shape instantiation is pure math — no SIMD variant
    }
}
