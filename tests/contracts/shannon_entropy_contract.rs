// CONTRACT: shannon-entropy-v1.yaml
// HASH: sha256:e1f2a3b4c5d67890
// Generated by: pv probar --binding
// DO NOT EDIT — regenerate with `pv probar --binding`

use proptest::prelude::*;

/// Compute Shannon entropy of a byte distribution.
/// H(X) = -sum(p_i * log2(p_i)), with 0*log2(0) := 0
fn shannon_entropy(data: &[u8]) -> f64 {
    if data.is_empty() {
        return 0.0;
    }
    let mut counts = [0u64; 256];
    for &b in data {
        counts[b as usize] += 1;
    }
    let n = data.len() as f64;
    let mut h = 0.0;
    for &c in &counts {
        if c > 0 {
            let p = c as f64 / n;
            h -= p * p.log2();
        }
    }
    h
}

/// Entropy of uniform distribution over k symbols.
fn uniform_entropy(k: u32) -> f64 {
    if k <= 1 {
        return 0.0;
    }
    (k as f64).log2()
}

proptest! {
    /// Obligation: Range bound (bound)
    /// Formal: 0 <= H(X) <= log2(256) = 8.0 for byte data
    #[test]
    fn prop_range_bound(
        data in proptest::collection::vec(0u8..=255, 1..256usize)
    ) {
        let h = shannon_entropy(&data);
        prop_assert!(
            h >= 0.0 && h <= 8.0 + 1e-10,
            "entropy={}, expected in [0, 8]", h
        );
    }

    /// Obligation: Constant input zero entropy (invariant)
    /// Formal: H([c, c, ..., c]) = 0.0 for any constant byte c
    #[test]
    fn prop_constant_zero_entropy(
        c in 0u8..=255,
        n in 1usize..256
    ) {
        let data: Vec<u8> = vec![c; n];
        let h = shannon_entropy(&data);
        prop_assert!(
            h.abs() < 1e-10,
            "constant byte {} repeated {} times: H={}, expected 0.0",
            c, n, h
        );
    }

    /// Obligation: Uniform entropy monotonic (monotonicity)
    /// Formal: k1 < k2 => H_uniform(k1) < H_uniform(k2)
    #[test]
    fn prop_uniform_entropy_monotonic(
        k1 in 2u32..255,
        delta in 1u32..10
    ) {
        let k2 = k1.saturating_add(delta).min(256);
        if k2 > k1 {
            let h1 = uniform_entropy(k1);
            let h2 = uniform_entropy(k2);
            prop_assert!(
                h2 > h1,
                "not monotonic: H_uniform({})={} >= H_uniform({})={}",
                k1, h1, k2, h2
            );
        }
    }

    /// Obligation: SIMD entropy equivalence (equivalence)
    #[test]
    #[ignore = "SIMD equivalence — trueno domain"]
    fn prop_simd_equivalence(
        _x in proptest::collection::vec(0u8..=255, 1..32usize)
    ) {
        // SIMD equivalence testing is trueno's responsibility
    }
}
