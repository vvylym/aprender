// CONTRACT: qk-norm-v1.yaml
// HASH: sha256:f2a3b4c5d6e78902
// Generated by: pv probar --binding
// DO NOT EDIT — regenerate with `pv probar --binding`

use aprender::autograd::Tensor;
use aprender::nn::Module;
use aprender::nn::RMSNorm;
use proptest::prelude::*;

proptest! {
    /// Obligation: Unit RMS after normalization (invariant)
    /// Formal: RMS(RMSNorm(x, 1)) ≈ 1.0
    /// Uses RMSNorm without affine (weight = 1) so normalized output has RMS ≈ 1.
    #[test]
    fn prop_rms_unit_norm(
        data in proptest::collection::vec(-10.0f32..10.0, 2..64usize)
            .prop_filter("non-zero input", |d| d.iter().any(|v| v.abs() > 0.01))
    ) {
        let n = data.len();
        let norm = RMSNorm::without_affine(&[n]);
        let x = Tensor::new(&data, &[1, n]);
        let y = norm.forward(&x);
        let y_data = y.data();

        // Compute RMS of output
        let sum_sq: f32 = y_data.iter().map(|v| v * v).sum();
        let rms = (sum_sq / n as f32).sqrt();

        prop_assert!(
            (rms - 1.0).abs() < 0.1,
            "RMS of normalized output = {rms}, expected ≈ 1.0"
        );
    }

    /// Obligation: Output amplitude bounded (bound)
    /// Formal: |output_i| <= |weight_i| * sqrt(d_k / ε)
    /// With unit weight and default eps=1e-5, bound = sqrt(d_k / 1e-5).
    #[test]
    fn prop_output_bounded(
        data in proptest::collection::vec(-100.0f32..100.0, 1..64usize)
    ) {
        let n = data.len();
        let norm = RMSNorm::new(&[n]);
        let x = Tensor::new(&data, &[1, n]);
        let y = norm.forward(&x);

        let eps = 1e-5_f32;
        let bound = (n as f32 / eps).sqrt();

        for (i, &val) in y.data().iter().enumerate() {
            prop_assert!(
                val.abs() <= bound,
                "output[{i}]={val} exceeds bound {bound}"
            );
        }
    }

    /// Obligation: Idempotent with unit weight (invariant)
    /// Formal: RMSNorm(RMSNorm(x, 1), 1) ≈ RMSNorm(x, 1)
    #[test]
    fn prop_idempotent(
        data in proptest::collection::vec(-10.0f32..10.0, 2..32usize)
            .prop_filter("non-zero input", |d| d.iter().any(|v| v.abs() > 0.01))
    ) {
        let n = data.len();
        let norm = RMSNorm::without_affine(&[n]);
        let x = Tensor::new(&data, &[1, n]);

        let y_once = norm.forward(&x);
        let y_twice = norm.forward(&y_once);

        let once_data = y_once.data();
        let twice_data = y_twice.data();
        for i in 0..n {
            let diff = (once_data[i] - twice_data[i]).abs();
            prop_assert!(
                diff < 0.1,
                "idempotent: y_once[{i}]={} vs y_twice[{i}]={}, diff={diff}",
                once_data[i], twice_data[i]
            );
        }
    }

    /// Obligation: Zero-input stability (invariant)
    /// Formal: RMSNorm(0, w) = 0
    #[test]
    fn prop_zero_input(
        n in 2usize..64
    ) {
        let data = vec![0.0f32; n];
        let norm = RMSNorm::new(&[n]);
        let x = Tensor::new(&data, &[1, n]);
        let y = norm.forward(&x);

        for (i, &val) in y.data().iter().enumerate() {
            prop_assert!(
                val.abs() < 1e-6,
                "RMSNorm(0)[{i}]={val}, expected 0"
            );
        }
    }

    /// Obligation: SIMD matches scalar within ULP (equivalence)
    #[test]
    #[ignore = "SIMD equivalence — trueno domain"]
    fn prop_simd_equivalence(
        _x in proptest::collection::vec(-10.0f32..10.0, 1..32usize)
    ) {
        // SIMD equivalence testing is trueno's responsibility
    }
}
