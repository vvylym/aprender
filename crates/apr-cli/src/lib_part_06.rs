
/// Dispatch extended commands (analysis, profiling, QA, benchmarks).
#[allow(clippy::too_many_lines)]
fn dispatch_extended_command(cli: &Cli) -> Result<(), CliError> {
    match cli.command.as_ref() {
        Commands::Cbtop {
            model,
            attach,
            model_path,
            headless,
            json,
            output,
            ci,
            throughput,
            brick_score,
            warmup,
            iterations,
            speculative,
            speculation_k,
            draft_model,
            concurrent,
            simulated,
        } => dispatch_cbtop(
            model.as_deref(),
            attach.as_deref(),
            model_path.as_deref(),
            *headless,
            *json,
            output.as_deref(),
            *ci,
            *throughput,
            *brick_score,
            *warmup,
            *iterations,
            *speculative,
            *speculation_k,
            draft_model.as_deref(),
            *concurrent,
            *simulated,
        ),

        Commands::Probar {
            file,
            output,
            format,
            golden,
            layer,
        } => probar::run(
            file,
            output,
            format.parse().unwrap_or(probar::ExportFormat::Both),
            golden.as_deref(),
            layer.as_deref(),
        ),

        Commands::CompareHf {
            file,
            hf,
            tensor,
            threshold,
            json,
        } => compare_hf::run(file, hf, tensor.as_deref(), *threshold, *json || cli.json),

        Commands::Hex {
            file,
            tensor,
            limit,
            stats,
            list,
            json,
            header,
            blocks,
            distribution,
            contract,
            entropy,
            raw,
            offset,
            width,
        } => dispatch_hex(
            file,
            tensor.as_deref(),
            *limit,
            *stats,
            *list,
            *json || cli.json,
            *header,
            *blocks,
            *distribution,
            *contract,
            *entropy,
            *raw,
            offset,
            *width,
        ),

        Commands::Tree {
            file,
            filter,
            format,
            sizes,
            depth,
        } => {
            // GH-248: Global --json flag overrides tree format
            let tree_format = if cli.json {
                tree::TreeFormat::Json
            } else {
                format.parse().unwrap_or(tree::TreeFormat::Ascii)
            };
            tree::run(file, filter.as_deref(), tree_format, *sizes, *depth)
        }

        Commands::Flow {
            file,
            layer,
            component,
            verbose,
            json,
        } => flow::run(
            file,
            layer.as_deref(),
            component.parse().unwrap_or(flow::FlowComponent::Full),
            *verbose || cli.verbose,
            *json || cli.json,
        ),

        Commands::Chat {
            file,
            temperature,
            top_p,
            max_tokens,
            system,
            inspect,
            no_gpu,
            gpu: _,
            trace,
            trace_steps,
            trace_verbose,
            trace_output,
            trace_level,
            profile,
        } => chat::run(
            file,
            *temperature,
            *top_p,
            *max_tokens,
            system.as_deref(),
            *inspect,
            *no_gpu,
            *trace,
            trace_steps.as_deref(),
            *trace_verbose,
            trace_output.clone(),
            trace_level.as_str(),
            *profile,
        ),

        Commands::Bench {
            file,
            warmup,
            iterations,
            max_tokens,
            prompt,
            fast,
            brick,
        } => bench::run(
            file,
            *warmup,
            *iterations,
            *max_tokens,
            prompt.as_deref(),
            *fast,
            brick.as_deref(),
            cli.json,
        ),

        Commands::Eval {
            file,
            dataset,
            text,
            max_tokens,
            threshold,
        } => eval::run(
            file,
            dataset,
            text.as_deref(),
            Some(*max_tokens),
            Some(*threshold),
            cli.json,
        ),

        Commands::Profile {
            file,
            granular,
            format,
            focus,
            detect_naive,
            threshold,
            compare_hf,
            energy,
            perf_grade,
            callgraph,
            fail_on_naive,
            output,
            ci,
            assert_throughput,
            assert_p99,
            assert_p50,
            warmup,
            measure,
            tokens,
            ollama,
            no_gpu,
            compare,
        } => dispatch_profile(
            file,
            *granular,
            format,
            focus.as_deref(),
            *detect_naive,
            *threshold,
            compare_hf.as_deref(),
            *energy,
            *perf_grade,
            *callgraph,
            *fail_on_naive,
            output.as_deref(),
            *ci,
            *assert_throughput,
            *assert_p99,
            *assert_p50,
            *warmup,
            *measure,
            *tokens,
            *ollama,
            *no_gpu,
            compare.as_deref(),
        ),

        Commands::Qa {
            file,
            assert_tps,
            assert_speedup,
            assert_gpu_speedup,
            skip_golden,
            skip_throughput,
            skip_ollama,
            skip_gpu_speedup,
            skip_contract,
            skip_format_parity,
            skip_ptx_parity,
            safetensors_path,
            iterations,
            warmup,
            max_tokens,
            json,
            verbose,
            min_executed,
            previous_report,
            regression_threshold,
            skip_gpu_state,
            skip_metadata,
        } => qa::run(
            file,
            *assert_tps,
            *assert_speedup,
            *assert_gpu_speedup,
            *skip_golden,
            *skip_throughput,
            *skip_ollama,
            *skip_gpu_speedup,
            *skip_contract,
            *skip_format_parity,
            *skip_ptx_parity,
            safetensors_path.clone(),
            *iterations,
            *warmup,
            *max_tokens,
            *json || cli.json,
            *verbose || cli.verbose,
            *min_executed,
            previous_report.clone(),
            *regression_threshold,
            *skip_gpu_state,
            *skip_metadata,
        ),

        Commands::Parity {
            file,
            prompt,
            assert,
        } => commands::parity::run(file, prompt, *assert, cli.verbose),

        Commands::PtxMap {
            file,
            kernel,
            reverse,
            json,
            verbose,
            prefill,
        } => commands::ptx_map::run(
            file,
            kernel.as_deref(),
            reverse.as_deref(),
            *json || cli.json,
            *verbose || cli.verbose,
            *prefill,
        ),

        Commands::Ptx {
            file,
            kernel,
            strict,
            bugs,
            json,
            verbose,
        } => ptx_explain::run(
            file.as_deref(),
            kernel.as_deref(),
            *strict,
            *bugs,
            *json || cli.json,
            *verbose || cli.verbose,
        ),

        Commands::Tune {
            file,
            method,
            rank,
            vram,
            plan,
            model,
            freeze_base,
            train_data,
            json,
        } => tune::run(
            file.as_deref(),
            method.parse().unwrap_or(tune::TuneMethod::Auto),
            *rank,
            *vram,
            *plan,
            model.as_deref(),
            *freeze_base,
            train_data.as_deref(),
            *json || cli.json,
        ),

        Commands::Showcase {
            auto_verify,
            step,
            tier,
            model_dir,
            baseline,
            zram,
            runs,
            gpu,
            json,
            verbose,
            quiet,
        } => dispatch_showcase(
            *auto_verify,
            step.as_deref(),
            tier,
            model_dir,
            baseline,
            *zram,
            *runs,
            *gpu,
            *json,
            *verbose,
            *quiet,
        ),

        Commands::Rosetta { action } => dispatch_rosetta(action, cli.json),

        Commands::Publish {
            directory,
            repo_id,
            model_name,
            license,
            pipeline_tag,
            library_name,
            tags,
            message,
            dry_run,
        } => publish::execute(
            directory,
            repo_id,
            model_name.as_deref(),
            license,
            pipeline_tag,
            library_name.as_deref(),
            tags.as_ref().map_or(&[], std::vec::Vec::as_slice),
            message.as_deref(),
            *dry_run,
            cli.verbose,
        ),

        Commands::Oracle {
            source,
            family,
            size,
            compliance,
            tensors,
            stats,
            explain,
            kernels,
            validate,
            full,
        } => oracle::run(
            source.as_ref(),
            family.as_ref(),
            size.as_ref(),
            *compliance,
            *tensors,
            cli.json,
            cli.verbose,
            cli.offline,
            oracle::OracleFlags {
                stats: *stats,
                explain: *explain,
                kernels: *kernels,
                validate: *validate,
                full: *full,
            },
        ),

        // All other commands handled by dispatch_core_command
        _ => unreachable!("dispatch_core_command handles all remaining variants"),
    }
}
